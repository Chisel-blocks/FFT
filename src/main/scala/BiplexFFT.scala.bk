// See LICENSE for license details.

// Author: Stevo Bailey (stevo.bailey@berkeley.edu)

package fft

import chisel3.util.{Counter, ShiftRegister, log2Up}
import chisel3.{Bool, Bundle, Data, Module, Reg, UInt, Vec, Wire, when}
import dsptools.numbers.{DspComplex, Real}
import dsptools.numbers.implicits._
import scala.math._

// fast fourier transform io
class BiplexFFTIO[T<:Data:Real](genIn: => DspComplex[T], genOut: => Option[DspComplex[T]] = None, val config: FFTConfig) extends Bundle {

  val data_in = Input(Vec(2, genIn))
  val sync_in = Input(UInt(log2Up(config.bp)))

  val data_out = Output(Vec(2, genOut.getOrElse(genIn)))
  val sync_out = Output(UInt(log2Up(config.bp)))

// fast fourier transform - cooley-tukey algorithm, decimation-in-time
// biplex pipelined version
// note, this is always a bp-point FFT
class BiplexFFT[T<:Data:Real](genIn: => DspComplex[T], genOut: => Option[DspComplex[T]] = None, genTwiddle: => Option[DspComplex[T]] = None,
  val config: FFTConfig = FFTConfig()) extends Module {

  val io = IO(new BiplexFFTIO(genIn, genOut, config))

  // sync
  val sync = List.fill(log2Up(config.bp)+1)(UInt())
  sync(0) := io.sync_in

  val twiddle_rom = Vec(config.twiddle.map(x => DspComplex.wire(implicitly[Real[T]].fromDouble(x(0)), implicitly[Real[T]].fromDouble(x(1)))))

  // TODO
  for (i <- 0 until log2Up(config.bp)) {

    // sync
    val stage_delay = (config.bp/pow(2,i+1)).toInt
    sync(i) := ShiftRegister(sync(i-1), config.b_pipe_delays(i))

    io.mux_sel(i) := 
    // other stages
    else {
      val pipe_amt = pipelines_per_stage + {if (stages_to_pipeline contains i) 1 else 0}
      pipe_sum = pipe_sum + pipe_amt
      val add_amt = (((pow(2, log2Up(n)-i-1)-pipe_sum+1)%n+n)%n).toInt
      //val add_amt = (((pow(2, log2Up(n)-i-1)-pipe_sum)%n+n)%n).toInt
      if (i == log2Up(n)-1) {
        idx(i) := Reverse( (io.sync_in + UInt(add_amt))(log2Up(n)-2,log2Up(n)-1-i) )
      }
      else {
        idx(i) := Cat(Reverse( (io.sync_in + UInt(add_amt))(log2Up(n)-2,log2Up(n)-1-i) ), UInt(0, log2Up(n)-i-1))
      }
    }
    io.twiddle(i) := Reg(next=twiddle_rom(idx(i))(ow-1, ow-stage_widths(i)))
    //io.twiddle(i) := twiddle_rom(idx(i))(ow-1, ow-stage_widths(i))
  }

  // sync 
  io.sync_out := ShiftRegister(io.sync_in, pipe)

  // bp-point decimation-in-time biplex pipelined FFT with outputs in bit-reversed order
  // TODO: change type? should it all be genIn?
  val stage_outputs = List.fill(log2Up(config.bp)+1)(List.fill(2)(Wire(genIn)))
  io.data_in.zip(stage_outputs(0)).foreach { case(in, out) => out := in }

  // create the FFT hardware
  for (i <- 0 until log2Up(config.bp)) {

    // hook it up
    val stage_delay = (config.bp/pow(2,i+1)).toInt
    val mux_out = BarrelShifter(Vec(stage_outputs(i)(0), ShiftRegisterMem(stage_outputs(i)(1), stage_delay)), io.mux_sel(i))
    stage_outputs(i+1).zip(Butterfly(List(ShiftRegisterMem(mux_out(0), stage_delay), mux_out(1)), io.twiddle(i))).foreach { x => 
      x._1 := ShiftRegister(x._2, config.b_pipe_amts(i))
    }

  }

}
